<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou Zhuming&#39;s blogs</title>
  
  <subtitle>你必须非常努力，才能看起来毫不费力。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-12T14:45:04.278Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhou Zhuming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github 如何同步更新一个你Fork的仓库？</title>
    <link href="http://yoursite.com/2018/06/12/Github-%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E4%BD%A0Fork%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/06/12/Github-如何同步更新一个你Fork的仓库？/</id>
    <published>2018-06-12T14:14:56.000Z</published>
    <updated>2018-06-12T14:45:04.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Configuring-a-remote-for-a-fork"><a href="#Configuring-a-remote-for-a-fork" class="headerlink" title="Configuring a remote for a fork"></a>Configuring a remote for a fork</h2><ul><li>先将你<code>fork</code>的远程仓库克隆到本地，利用命令<code>git clone + repository url</code>即可完成</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zmzhouXJTU/Problem-sets</span><br></pre></td></tr></table></figure><ul><li><p>给<code>fork</code>配置一个<code>remote</code></p></li><li><p>可以使用<code>git remote -v</code>查看远程仓库的状态</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/zmzhouXJTU/Problem-sets (fetch)</span><br><span class="line">origin  https://github.com/zmzhouXJTU/Problem-sets (push)</span><br></pre></td></tr></table></figure><ul><li>添加一个将被同步给<code>fork</code>远程的上游仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream https://github.com/ACLoong/Problem-sets</span><br></pre></td></tr></table></figure><ul><li>再次查看状态确定是否配置成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/zmzhouXJTU/Problem-sets (fetch)</span><br><span class="line">origin  https://github.com/zmzhouXJTU/Problem-sets (push)</span><br><span class="line">upstream        https://github.com/ACLoong/Problem-sets (fetch)</span><br><span class="line">upstream        https://github.com/ACLoong/Problem-sets (push)</span><br></pre></td></tr></table></figure><h2 id="Syncing-a-fork"><a href="#Syncing-a-fork" class="headerlink" title="Syncing a fork"></a>Syncing a fork</h2><ul><li>从上游仓库<code>fetch</code>分支和提交点，将其传送至本地，它会被存储在一个本地分支upstream/master, 利用命令<code>git fetch upstream</code>来实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch upstream</span><br><span class="line">remote: Counting objects: 21, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (15/15), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 21 (delta 4), reused 5 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (21/21), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/ACLoong/Problem-sets</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure><ul><li>切换到本地主分支(<strong>如果当前不在的话</strong>)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># Switched to branch 'master'</span></span><br></pre></td></tr></table></figure><ul><li>把upstream/master分支合并到本地的master分支上，这样就完成了同步，并且不会丢失掉本地修改的内容。可利用命令<code>git merge upstream/master</code>来实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge upstream/master</span><br><span class="line">Updating 60b537a..426148c</span><br><span class="line">Fast-forward</span><br><span class="line"> problem_set/first_week/refs/Process&amp;Thread.md | 29 +++++++++++++++++++++++++++</span><br><span class="line"> 1 file changed, 29 insertions(+)</span><br><span class="line"> create mode 100644 problem_set/first_week/refs/Process&amp;Thread.md</span><br></pre></td></tr></table></figure><ul><li>将其更新到Github远程仓库的<code>fork</code>上，可以利用命令<code>git push origin master</code>来实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 21, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (16/16), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (21/21), 5.65 KiB | 1.88 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 21 (delta 4), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (4/4), completed with 2 <span class="built_in">local</span> objects.</span><br><span class="line">To https://github.com/zmzhouXJTU/Problem-sets</span><br><span class="line">   60b537a..426148c  master -&gt; master</span><br></pre></td></tr></table></figure><p>好了，至此任务就完成了。不知你是否看明白了呢？有任何问题，欢迎再此博客下方评论留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Configuring-a-remote-for-a-fork&quot;&gt;&lt;a href=&quot;#Configuring-a-remote-for-a-fork&quot; class=&quot;headerlink&quot; title=&quot;Configuring a remote for a for
      
    
    </summary>
    
      <category term="版本控制之Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B9%8BGit/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限</title>
    <link href="http://yoursite.com/2018/04/26/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2018/04/26/Linux文件权限/</id>
    <published>2018-04-26T12:36:43.000Z</published>
    <updated>2018-06-08T07:23:24.857Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 操作系统中，权限是一个非常重要的东西。 它无时无刻不在影响着你的各种操作。就像有的时候，你想去百度云下载一些别人分享的文件，可是你却发现虽然你能看到文件但是你却不能下载，这就是一种权限的典型例子。在 Linux 中, 这种权限随处可见。你可以设置，让别人不能越界。</p><p>不过像我这种人，也就是一台电脑， 一个用户(手动滑稽)，涉及不到多少有关权限方面的问题。 如果你也和我差不多，只有你自己在用 Linux 的电脑，主要用它来运行你的代码。我教你一招来修改权限，并且方便运行你的 Python 脚本的招数。</p><p>这里不会涉及过深的权限管理。我们了解一些基础，方便你拿你的 Linux 跑机器学习的代码就好。如果你想扩展学习的话, 网上会有很多教程。可以自行谷歌。</p><hr><h2 id="ls查看权限"><a href="#ls查看权限" class="headerlink" title="ls查看权限"></a>ls查看权限</h2><p>查看文件权限的方法很简单，其实在之前我的上一篇博文就讲了这个内容。 如果你还记得的话，我们在说 <code>ls</code>指令的时候, 提到过权限问题， 不过到了这节内容我们仔细的来说一说权限。如果你在 Terminal 中输入如下图片中的指令：</p><p><img src="/2018/04/26/Linux文件权限/1.png" alt="Linux文件权限查看"></p><p>如上图所示，在 Terminal 中查看文件的权限的命令可以用<code>ls -l</code>  或者<code>ls -lh</code>，这个是看当前目录下面所有文件的权限，如果你只是想单独看看某一个具体的文件的权限，只需要在后面加上相应的文件名就可以了，比如<code>ls -lh p1.py</code>。</p><p>我们看到的上图中的<code>-rw-rw-r--</code>就是相关的权限啦。那么这些具体又是表达什么意思的呢？看下面的图就明白啦。</p><p><img src="https://morvanzhou.github.io/static/results/linux-basic/03-01-02.png" alt="Linux文件权限说明"></p><ul><li><p><code>Type</code>: 很多种 (最常见的是 <code>-</code> 为文件, <code>d</code> 为文件夹, 其他的还有<code>l</code>, <code>n</code> … 这种东西, 真正自己遇到了, 网上再搜就好, 一次性说太多记不住的)。</p></li><li><p><code>User</code>: 后面跟着的三个空是使用 User 的身份能对这个做什么处理 (<code>r</code> 可读; <code>w</code> 可写; <code>x</code> 可执行; <code>-</code> 不能完成某个操作)。</p></li><li><p><code>Group</code>: 一个 Group 里可能有一个或者多个 user, 这些权限的样式和 User 一样。</p></li><li><p><code>Others</code>: 除了 User 和 Group 以外人的权限。</p></li></ul><p>如果有人对 User, group, others 这三个没什么概念的话，我这里补充一下。User 一般就是指你，这个当前正在使用电脑的人。 Group 是一个 User 的集合，最开始创建新 User 的时候, 他也为这个 User 创建了一个和 User 一样名字的 Group, 这个新 Group 里只有这个 User。一般来说，像一个企业部门的电脑，都可以放在一个 Group 里, 分享了一些共享文件和权限。Others 就是除了上面提到的 User 和 Group 以外的人。</p><p>好了, 有了这些理解, 我们拿上面的 p1.py 来举例. 我们可以将 <code>-rw-rw-r--</code> 拆成 - (这是文件), -rw(这个 User可以读,写), rw- (这个Group里可以读,写), r– (其他人只能读)。</p><hr><h2 id="chmod-修改权限"><a href="#chmod-修改权限" class="headerlink" title="chmod 修改权限"></a>chmod 修改权限</h2><p>好了, 我们知道了这些权限的问题, 那我们如何来改写权限呢? <code>chmod</code> (change mode)命令就是来干这个的。</p><p>通常的修改形式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ chmod [谁] [怎么修改] [哪个文件]</span><br></pre></td></tr></table></figure><p>举个最简单的例子, 现在的 p1.py 的权限是 <code>-rw-rw-r--</code>, 如果我们想让user和group拥有执行的能力。按照下面这样来改就行了。<br>相应的结果如下图所示：</p><p><img src="/2018/04/26/Linux文件权限/2.png" alt="用chmod修改Linux文件权限"></p><p>这里的 ug+x 很形象, User,Group + execute , 给 p1.py 这个文件进行修改。所以我们的修改形式就能总结出下面这样：</p><p><strong>[谁]</strong></p><ul><li><code>u</code>: 对于 User 修改</li><li><code>g</code>: 对于 Group 修改</li><li><code>o</code>: 对于 Others 修改</li><li><code>a</code>: (all) 对于所有人修改</li></ul><p><strong>[怎么修改]</strong></p><ul><li><code>+</code>, <code>-</code>, <code>=</code>: 作用的形式, 加上, 减掉, 等于某些权限</li><li><code>r</code>, <code>w</code>, <code>x</code> 或者多个权限的组合, 比如 <code>rx</code></li></ul><p><strong>[哪个文件]</strong></p><ul><li>施加操作的文件, 可以为多个文件</li></ul><p>除了上面这些修改形式, 还有一些简化版的形式, 就是用数字来表示相应的权限，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><hr><h2 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h2><ul><li><p>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</p></li><li><p>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</p></li></ul><hr><h2 id="一个使用Python的技巧"><a href="#一个使用Python的技巧" class="headerlink" title="一个使用Python的技巧"></a>一个使用Python的技巧</h2><p>我不怎么用权限这东西, 但是我却发现给 python 文件添加权限<code>x</code> 还算有用的. 为什么这么说? 因为通常, 如果一个 <code>.py</code> 没有<code>x</code> 权限, 在 terminal 中你就需要这样执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Folder1$ python3 p1.py</span><br></pre></td></tr></table></figure><p>如果你有了 <code>x</code> (可执行权限), 你运行这个文件可以直接这样打:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Folder1$ ./p1.py</span><br></pre></td></tr></table></figure><p>很酷炫有木有？但是上面这个脚本能够成功运行有一个前提，那就是你在这个Python脚本p1.py的开头加上一句话，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">print(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure><p>好了，加上上面这句话的话以后运行这个脚本就可以直接用那本很酷炫的方式而不用每次都<code>python3 xx.py</code>啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Linux 操作系统中，权限是一个非常重要的东西。 它无时无刻不在影响着你的各种操作。就像有的时候，你想去百度云下载一些别人分享的文件，可是你却发现虽然你能看到文件但是你却不能下载，这就是一种权限的典型例子。在 Linux 中, 这种权限随处可见。你可以设置，让别人不能
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="http://yoursite.com/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2018/04/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/04/26/Linux常用命令/</id>
    <published>2018-04-26T01:45:24.000Z</published>
    <updated>2018-06-08T07:23:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，相信大家对Linux操作系统都不会陌生。但是Linux系统那些繁杂的操作命令通常让我们很头疼，我也在网上查阅了很多资料，做了一些总结。这里将常用的一些Linux操作命令(主要是与文件相关的操作命令)整理如下：</p><hr><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>这个SuperUserDo(简写成”sudo”)是Linux新手要使用的最重要的命令。需要根权限的每一个命令都需要这个<code>sudo</code>命令。你可以在需要根权限的每个命令之前使用<code>sudo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br></pre></td></tr></table></figure><hr><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ <span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 获取当前所在的路径(绝对路径)</span></span><br></pre></td></tr></table></figure><hr><h2 id="ls-list"><a href="#ls-list" class="headerlink" title="ls(list)"></a>ls(list)</h2><p>借助<code>ls</code>(list)命令，终端就会显示你正在处理的那个目录里面的所有文件和文件夹。假设我在Home目录(也就是”~”)里面，想查看当前目录下的文件夹和文件。相应的命令如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ ls</span><br><span class="line"><span class="comment"># 显示当前目录的所有文件和文件夹</span></span><br></pre></td></tr></table></figure><p>上面是<code>ls</code>命令最基本的使用方式，下面我们再看看<code>ls</code>命令其他的使用方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ ls -l</span><br><span class="line"><span class="comment"># 输出详细信息 -l (long 的简写). 这个指令会打印出文件的权限 (-rw-rw-r-- 之后我们在细说这个), 用户名, 文件大小, 修改日期, 文件名</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ ls -a</span><br><span class="line"><span class="comment"># -a (all 的简写) 显示所有文件 . 这里还会显示隐藏的文件 (以 . 开头的)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ ls -lh</span><br><span class="line"><span class="comment"># -lh (human), 直接 -l 不方便人看, 这个指令是为了方便给人观看的. 注意这里的文件大小使用了 K, MB, GB 之类概括</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ ls --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 还有很多其他的功能, 我们可以通过 --help 来查看</span></span><br></pre></td></tr></table></figure><hr><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>更改目录(<code>cd</code>)是始终在终端中使用的主要命令。它是最基本的Linux命令之一。使用这个命令很简单。只要输入你想要从当前目录进入到的那个文件夹的名称(如果是多层，中间用”/“进行分隔)。如果想要返回上一级，只要将双圆点(..)作为参数。</p><p>假设我在Home目录(也就是”~”)中，想进入到在Home目录里面的Documents子目录。下面是我可以使用<code>cd</code>命令的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ <span class="built_in">cd</span> Documents/</span><br><span class="line"><span class="comment"># 跳转到对应的Documents目录</span></span><br></pre></td></tr></table></figure><p>若果要想返回到上一级目录，只用将双圆点(..)作为相应的参数即可。如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># 返回上一级目录</span></span><br></pre></td></tr></table></figure><p>除了上面两个基本的命令之外，还有一些有趣的，我们来看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ <span class="built_in">cd</span> Documents/Folder1/</span><br><span class="line"><span class="comment"># 去往子文件夹Folder1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Folder1$ <span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 返回你刚刚所在的目录(也就是你的上一条命令所在的目录)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Folder1$ <span class="built_in">cd</span> ../../</span><br><span class="line"><span class="comment"># 向上返回两次(再往上返回可以依次类推)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Folder1$ <span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># 去往Home</span></span><br></pre></td></tr></table></figure><hr><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p><code>touch</code> 命令的意思的新建，它的使用很简单。我们先去往 Documents 的文件夹, 里面已经有了 folder1 和 file1, 如果我们想新建一个 file2 使用下面的语句就好(可以指定文件的扩展名)。一个空文件就这样建立好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$  touch file2.txt</span><br><span class="line"><span class="comment"># 建立一个文件名为file2的空的文本文档</span></span><br></pre></td></tr></table></figure><p>如果你想同时建立多个文件，输入多个文件的名字，以空格分开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$  touch file3.txt file4.txt file5.txt</span><br><span class="line"><span class="comment"># 同时建立三个空的文本文档(也可以不指定文件的扩展名)</span></span><br></pre></td></tr></table></figure><hr><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>拷贝粘贴是我们为了组织整理文件而需要完成的重要任务。使用<code>cp</code>将帮助你从终端拷贝粘贴文件。首先，你确定想要拷贝的那个文件，然后输入目的地位置，即可粘贴文件。<code>cp</code> (copy) 是复制文件或者文件夹的指令, 常用的方式是复制 “老文件” 到 “新文件”。即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ cp 老文件 新文件</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 如果你将文件拷贝到任何新文件都需要根权限的目录，那么你就需要使用<code>sudo</code>命令。</p><p>下面是<code>cp</code>命令的一些常见操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp file1 file1copy</span><br><span class="line"><span class="comment"># 将file1复制成file1copy</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp -i file1 file1copy</span><br><span class="line"><span class="comment"># -i (interactive) 注意: 如果 file1copy 已经存在, 它将会直接覆盖已存在的 file1copy, 如果要避免直接覆盖, 我们在 cp 后面加一个选项。</span></span><br><span class="line"><span class="comment"># 在这句问句后面打上 “Yes”, “Y”, 或者任何大小写形式的 “y” 和 “yes”, 它将进行覆盖操作. 直接回车或者打其他字母, 就会放弃复制这项操作。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp file1 Folder1/</span><br><span class="line"><span class="comment"># 将file1复制到文件夹Folder1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp -R Folder1/ Folder2/</span><br><span class="line"><span class="comment"># 复制文件夹, 需要加上 -R (recursive)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp file* Folder1/</span><br><span class="line"><span class="comment"># 复制多个文件。复制名字部分相同的多个文件到某个文件夹, * 是说"你就找文件名前面是 file 的文件, 后面是什么名字无所谓"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cp file2.txt file5.txt Folder1/</span><br><span class="line"><span class="comment"># 或者你可以单独选定几个文件, cp 会默认最后一个选项是要复制去的文件夹. 比如把 file2.txt 和 file5.txt 复制去 Folder1/</span></span><br></pre></td></tr></table></figure><hr><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>知道了 <code>cp</code>, <code>mv</code>就好理解多了, 基本是一样的。<code>mv</code>是剪切(移动)的命令。<br>下面是<code>mv</code>命令的一些常见操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ mv file1 Folder1/</span><br><span class="line"><span class="comment"># 将file1移动到文件夹Folder1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ mv file1 file1rename</span><br><span class="line"><span class="comment">#  重命名文件file1为file1rename。因为移动文件到原始的地点, 但是以不同的文件名。所以这种做法不就是在重命名嘛!</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ mv -f file1 Folder2/</span><br><span class="line"><span class="comment">#  将文件file1强制移动到Folder2文件夹下。如果目标文件已经存在，不会询问而会直接覆盖。</span></span><br></pre></td></tr></table></figure><p>最后还是想要提一句, 如果想要查看使用说明, 直接在指令后面打上 <code>--help</code>就能查看.</p><hr><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>仅仅会更改目录还不全面。有时候，你想要创建一个新的文件夹或子文件夹。可以使用<code>mkdir</code>命令来做到这一点。只要在终端中将你的文件夹名称放在<code>mkdir</code>命令的后面即可。<br><code>mkdir</code> (make directory) 就是创建一个文件夹的意思, 使用起来很简单。</p><p>以下是<code>mkdir</code>命令的一些常见操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ mkdir  Folder2/</span><br><span class="line"><span class="comment"># 在Documents文件夹下创建一个文件夹Folder2</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ mkdir  Folder2/folder</span><br><span class="line"><span class="comment"># 在文件夹Folder2里面再创建一个子文件夹folder</span></span><br></pre></td></tr></table></figure><hr><h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p><code>rmdir</code>(remove directory) 也就是字面的意思，即移除文件夹。<strong>不过这有一个前提条件. 这些要移除的文件夹必须是空的，不然会失败</strong>。所以如果想刚刚建立的那个 Folder2 就不能被移除, 因为里面有个 folder 文件夹。那么怎么移除有文件的文件夹呢？这里需要用到我们后面讲的<code>rm</code>命令。</p><p>要移除个空文件夹, 比如我在新建一个 Folder3, 然后移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ rmdir  Folder3</span><br><span class="line"><span class="comment"># 删除文件夹Folder3(rmdir只能移除空文件夹！！！)</span></span><br></pre></td></tr></table></figure><hr><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>rm</code>这个命令可以移除你的文件，甚至移除你的目录。如果文件需要根权限才能移除，可以使用<code>-f</code>。你还可以使用<code>-r</code>来进行递归移除，从而移除你的文件夹。</p><p><strong>注意: 执行了 <code>rm</code>以后是不能进行返回操作的, 请确保别执行像这样的操作 <code>rm /</code>，这会清空你的电脑</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ rm  file1</span><br><span class="line"><span class="comment"># 删除单个文件filer1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ rm -i file2</span><br><span class="line"><span class="comment"># -i 或 -I 有提示地移除文件 (为了避免误删)</span></span><br><span class="line"><span class="comment"># -i 会每个要移除的文件都进行提示</span></span><br><span class="line">~/Documents$ rm -i file2 fil3 file4 file5</span><br><span class="line"><span class="comment"># -I 超过3个文件才进行提示</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ rm -r Folder1/</span><br><span class="line"><span class="comment"># -r 或 -R (recursively) 用来删文件夹</span></span><br><span class="line"><span class="comment"># 和 rmdir 不同, rm -r 可以在文件夹中有文件的情况下删除这个文件夹. 比如我的 Folder1 里有 file1 和 file2 两个文件.</span></span><br></pre></td></tr></table></figure><p><code>rm</code>命令其他的特点和<code>cp</code>命令差不多，比如用带相应的前缀或者后缀(或者不带，这样会清空当前文件夹下所有文件)加’*’来一次性删除多个文件。</p><hr><h2 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h2><p><code>nano</code>是 linux 的一款文字编辑工具. 我们可以拿它来做最基本的 terminal 端的文本编辑, 甚至可以写代码。下面我们用 <code>touch</code> 创建一个 Python 脚本。如果大家不懂<br><code>Python</code> 也没关系，你就知道我们可以拿 <code>nano</code>来编辑文字或者脚本就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ touch  p1.py</span><br><span class="line"><span class="comment"># 在Documents目录下创建一个python文件</span></span><br></pre></td></tr></table></figure><p>然后用 nano 执行这个 p1.py 文件，如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ nano  p1.py</span><br><span class="line"><span class="comment"># 用nano命令执行这个文件</span></span><br></pre></td></tr></table></figure><p>它就会变成一个文本编辑器, 你在里面可以写上一些脚本。<br>然后按 “Ctrl + x” 来保存和退出。如果提示你保存, 你就按一下 “y” 键, 然后回车, 你的文件就被保存下来了。</p><p>接着如果你在 terminal 中输入相关的执行python文件的命令，你就能看到 terminal 执行了你的 python 文件。</p><hr><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>作为用户，你常常需要查看来自脚本的一些文档或代码。同样，其中一个Linux基本命令是<code>cat</code>命令。它会为你显示文件里面的文本。</p><p><code>cat</code>(catenate) 可以用来显示文件内容, 或者是将某个文件里的内容写入到其他文件里。详细的操作见下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cat  p1.py &gt; p2.py</span><br><span class="line">~/Documents$ cat  p2.py</span><br><span class="line"><span class="comment"># &gt; 将文件的内容放到另一个文件里，这里我们将p1.py的内容写入到p2.py里面。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cat  p1.py p2.py &gt; p3.py</span><br><span class="line">~/Documents$ cat  p3.py</span><br><span class="line"><span class="comment"># &gt; 将多个文件的内容打包一起放入另一个文件，这里我们将p1.py的内容和p1.py的内容一同写入到p2.py里面。</span></span><br><span class="line"><span class="comment"># 在显示的时候，两个文件的内容会分开显示</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ cat  p2.py &gt;&gt; p3.py</span><br><span class="line">~/Documents$ cat  p3.py</span><br><span class="line"><span class="comment"># &gt;&gt; 将内容添加在一个文件末尾，这里我们将p2.py的内容添加到p3.py的末尾。</span></span><br></pre></td></tr></table></figure><hr><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ head -n 5 p2.py</span><br><span class="line"><span class="comment"># 查看文件的前几行(默认查看前10行)</span></span><br><span class="line"><span class="comment"># head [-n number] filename</span></span><br><span class="line"><span class="comment"># -n ：后面接数字，代表显示几行的意思</span></span><br></pre></td></tr></table></figure><hr><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ tail -n 6 p3.py</span><br><span class="line"><span class="comment"># 查看文件的后几行(默认查看倒数后10行)</span></span><br><span class="line"><span class="comment"># tail [-n number] filename</span></span><br><span class="line"><span class="comment"># -n ：后面接数字，代表显示几行的意思</span></span><br></pre></td></tr></table></figure><hr><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p>就不同的发行版而言，这个命令各不相同。在基于Debian的Linux发行版中，想安装、移除和升级任何软件包，我们可以使用高级包装工具(APT)软件包管理器。<code>apt-get</code>命令可帮助你安装需要在Linux中运行的软件。这是个功能强大的命令行工具，可以执行安装、升级、甚至移除软件这类任务。</p><p>在其他发行版(比如Fedora和Centos)中，有不同的软件包管理器。Fedora过去有<code>yum</code>，但现在它有<code>dnf</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ sudo dnf update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ sudo apt-get install &lt;package name&gt;</span><br><span class="line"><span class="comment"># 安装相应的软件或工具</span></span><br></pre></td></tr></table></figure><hr><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>你需要找到一个文件，但是又记不得它的确切位置或路径。<code>grep</code>可以帮助你解决这个问题。你可以使用<code>grep</code>命令，根据给定的关键字帮助找到文件。</p><p><code>grep</code>是一种强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class="line"><span class="comment"># -a ： 将 binary 文件以 text 文件的方式进行搜寻</span></span><br><span class="line"><span class="comment"># -c ： 计算找到个数</span></span><br><span class="line"><span class="comment"># -i ： 忽略大小写</span></span><br><span class="line"><span class="comment"># -n ： 输出行号</span></span><br><span class="line"><span class="comment"># -v ： 反向选择，亦即显示出 没有搜寻字符串内容 的那一行</span></span><br><span class="line"><span class="comment"># --color=auto ：找到的关键字加颜色显示</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/Documents$ grep hello p1.python</span><br><span class="line"><span class="comment"># 在p1.py文件中搜索"hello"这个单词</span></span><br></pre></td></tr></table></figure><p>范例：把含有 the 字符串的行提取出来(注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n <span class="string">'the'</span> regular_express.txt</span><br><span class="line"><span class="comment"># 以下为相应的显示结果</span></span><br><span class="line"><span class="comment"># 8:I can't finish the test.</span></span><br><span class="line"><span class="comment"># 12:the symbol '*' is represented as start.</span></span><br><span class="line"><span class="comment"># 15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="comment"># 16:The world Happy is the same with "glad".</span></span><br><span class="line"><span class="comment">#18:google is the best tools for search keyword</span></span><br></pre></td></tr></table></figure><p><strong>因为 <code>{ 和 }</code>在 <code>shell</code> 是有特殊意义的，因此必须要使用转义字符进行转义。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n <span class="string">'go\&#123;2,5\&#125;g'</span> regular_express.txt</span><br></pre></td></tr></table></figure><p><code>grep</code>还有很多更强大的用法，后续会继续更新。当然，具体的用法可以通过<code>grep --help</code>进行查看。</p><hr><h2 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h2><p>有时候，你需要直接从终端来进行关机。这个命令就能完成这项任务，别忘了在命令的开头添加<code>sudo</code>，因为它需要根权限才能执行<code>poweroff</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo poweroff</span><br></pre></td></tr></table></figure><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>好了，基本的<code>Linux</code>命令大概就这么多。它会帮助你在这个早期阶段开始使用<code>Linux</code>，借助这些基本的<code>Linux</code>命令，开始使用<code>Linux</code>，并且定个目标：每天学会使用1个至3个命令。后续我也会继续更新~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名程序员，相信大家对Linux操作系统都不会陌生。但是Linux系统那些繁杂的操作命令通常让我们很头疼，我也在网上查阅了很多资料，做了一些总结。这里将常用的一些Linux操作命令(主要是与文件相关的操作命令)整理如下：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;sudo&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux操作系统" scheme="http://yoursite.com/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令整理</title>
    <link href="http://yoursite.com/2018/04/24/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/24/Git常用命令整理/</id>
    <published>2018-04-24T02:25:17.000Z</published>
    <updated>2018-06-08T07:22:29.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言碎碎念"><a href="#前言碎碎念" class="headerlink" title="前言碎碎念"></a>前言碎碎念</h2><p>自从使用Git作为版本控制工具以来，通过教程学习、手册查阅方式了解了Git的相关原理和Git的命令，能够顺利使用。但由于还不熟练，实践经验也还不够丰富，每次遇到问题都需要重新搜索，多次下来十分麻烦。另一方面，查阅手册往往是不够的，因为手册只会告诉你什么命令做什么用，不会根据不同场景告诉你应该用什么命令。</p><p>所以在这篇文章中，我将常用的Git命令根据不同的使用场景做一个整理，加深印象的同时也方便自己日后进行查阅。</p><hr><h2 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h2><p>这里借用阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">《常用Git命令清单》</a>中的图。<br><img src="/2018/04/24/Git常用命令整理/1.png" alt="Git"></p><p>几个专有名词的译名如下：</p><ul><li>Workspace: 工作区，也就是正在编辑的文件目录</li><li>Index / Stage: 暂存区</li><li>Repository: 本地仓库，.git文件夹管理的版本库</li><li>Remote: 远程仓库，也就是github.com上面的仓库</li></ul><p>例如，在最常用的命令串中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file&gt;</span><br><span class="line"><span class="comment">#添加工作区指定文件的改动到暂存区，"&lt;file&gt;"为"."时添加全部文件</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XXXX"</span></span><br><span class="line"><span class="comment">#提交暂存区的所有内容到本地仓库的当前分支</span></span><br><span class="line"></span><br><span class="line">$ git push -u origin master</span><br><span class="line"><span class="comment">#上传本地仓库到已关联的远程仓库</span></span><br></pre></td></tr></table></figure><hr><h2 id="建立工程"><a href="#建立工程" class="headerlink" title="建立工程"></a>建立工程</h2><p>在工作目录中建立与远程仓库关联的Git工程主要有两种情况：第一种是由本地上传到远程仓库；第二种是从远程仓库克隆到本地。</p><h3 id="本地上传"><a href="#本地上传" class="headerlink" title="本地上传"></a>本地上传</h3><p>在这种情况下，远程仓库应该是没有工程的。在本地工程文件夹下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line"><span class="comment">#初始化一个Git仓库，此时当前目录会增加一个.git文件夹(此文件夹默认是隐藏的)，当前文件夹受到Git的管理，并默认创建master分支</span></span><br><span class="line"></span><br><span class="line">$ git add &lt;file&gt;</span><br><span class="line"><span class="comment">#添加指定文件到暂存区，"&lt;file&gt;"为"."时表明添加当前目录的所有文件到暂存区</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"XXXX"</span></span><br><span class="line"><span class="comment">#提交暂存区的所有内容到本地仓库的当前分支</span></span><br><span class="line"></span><br><span class="line">$ git remote add origin &lt;url&gt;</span><br><span class="line"><span class="comment">#为当前项目添加远程主机。</span></span><br><span class="line"><span class="comment">#其中origin为自定义的远程主机名，url为远程主机的地址（推荐采用ssh协议）</span></span><br></pre></td></tr></table></figure><p>此时已经建立了本地仓库与远程仓库的关联，可以通过<code>git push</code>推送上传。<br>第一次推送采用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line"><span class="comment">#将本地master分支推送到远程同名分支（若不存在则新建），同时-u指定origin为默认主机名，之后若要上传到origin可省略它。</span></span><br></pre></td></tr></table></figure><h3 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h3><p>这种情况下，远程仓库已经有工程，只需要在本地工程文件夹下用<code>git clone</code>命令克隆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure><p>此时本地仓库已经与对应远程仓库建立关联，为主机名<code>origin</code>的地址。</p><h3 id="克隆其他分支"><a href="#克隆其他分支" class="headerlink" title="克隆其他分支"></a>克隆其他分支</h3><p><code>git clone</code>命令默认克隆远程项目的<code>master</code>分支及其历史，若还需克隆别的分支，可通过以下方式进行（以克隆dev分支为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br><span class="line"><span class="comment">#检出origin下的dev分支到本地新建的dev分支，并建立本地分支与远程分支的追踪关系</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line"><span class="comment">#新建并切换到本地分支dev</span></span><br><span class="line"></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br><span class="line"><span class="comment">#建立origin/dev远程分支和dev本地分支的追踪关系</span></span><br><span class="line"></span><br><span class="line">$ git pull</span><br><span class="line"><span class="comment">#拉取本地分支dev对应的远程分支的最新状态</span></span><br></pre></td></tr></table></figure><h3 id="托管到新的远程仓库"><a href="#托管到新的远程仓库" class="headerlink" title="托管到新的远程仓库"></a>托管到新的远程仓库</h3><p>在克隆需要的内容后，有时会希望托管到新的远程仓库。<br>此时可以增加新的远程主机名:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;new_remote_name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>或者干脆更改原来<code>origin</code>的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote origin <span class="built_in">set</span>-url &lt;url&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"><span class="comment">#查看本地分支</span></span><br><span class="line"></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment">#查看远程分支</span></span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line"><span class="comment">#查看所有本地分支和远程分支</span></span><br></pre></td></tr></table></figure><h3 id="新建本地分支"><a href="#新建本地分支" class="headerlink" title="新建本地分支"></a>新建本地分支</h3><p>新建分支（不切换）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;new_branch&gt;</span><br></pre></td></tr></table></figure><p>新建分支并切换到新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;new_branch&gt;</span><br><span class="line"><span class="comment">#相当于：</span></span><br><span class="line">$ git branch &lt;new_branch&gt;</span><br><span class="line">$ git checkout &lt;new_branch&gt;</span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"><span class="comment">#删除分支前检查该分支是否有未提交或者未合并的内容</span></span><br><span class="line"></span><br><span class="line">$ git branch -D &lt;branch&gt;</span><br><span class="line"><span class="comment">#强制删除该分支</span></span><br></pre></td></tr></table></figure><h3 id="新建远程分支"><a href="#新建远程分支" class="headerlink" title="新建远程分支"></a>新建远程分支</h3><p>相当于把远程未添加的本地分支push到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;</span><br><span class="line"><span class="comment">#建议远程与本地分支同名，同名时可省略远程分支名</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>相当于<code>push</code>一个本地的空分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :&lt;remote_branch&gt;</span><br><span class="line"><span class="comment">#本地分支为空</span></span><br></pre></td></tr></table></figure><p>或者用<code>--delete</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete &lt;remote_branch&gt;</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;</span><br><span class="line"><span class="comment">#快进合并（指针指向改变），合并&lt;branch&gt;到当前分支</span></span><br><span class="line"></span><br><span class="line">$ git merge --no-ff &lt;branch&gt;</span><br><span class="line"><span class="comment">#合并&lt;branch&gt;到当前分支，在当前分支生成新节点，保证每个分支的独立演变史</span></span><br></pre></td></tr></table></figure><hr><h2 id="撤销与版本回退"><a href="#撤销与版本回退" class="headerlink" title="撤销与版本回退"></a>撤销与版本回退</h2><h3 id="撤销工作区修改"><a href="#撤销工作区修改" class="headerlink" title="撤销工作区修改"></a>撤销工作区修改</h3><p>有时修改工作区后，发现修改错误，希望回到原来未修改时（上一次提交或暂存）的状态。可以采用<code>git checkout</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line"><span class="comment">#查看工作区未提交（或为暂存）的文件的具体修改</span></span><br><span class="line"></span><br><span class="line">$ git checkout -- &lt;file&gt;</span><br><span class="line"><span class="comment">#恢复工作区指定文件到上一次提交（或暂存）状态</span></span><br><span class="line">$ git checkout .</span><br><span class="line"><span class="comment">#撤销所有工作区修改</span></span><br></pre></td></tr></table></figure><h3 id="撤销暂存"><a href="#撤销暂存" class="headerlink" title="撤销暂存"></a>撤销暂存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"><span class="comment">#将指定文件撤出暂存区</span></span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>希望将版本库回退到之前的提交时，采用<code>git reset</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment">#查看之前的版本提交记录</span></span><br><span class="line"></span><br><span class="line">$ git reset HEAD^</span><br><span class="line"><span class="comment">#回退到上一个提交版本，^^代表上两个版本，以此类推。（也可以用~2等代替）</span></span><br><span class="line">或</span><br><span class="line">$ git reset &lt;commitID&gt;</span><br><span class="line"><span class="comment">#commitID可由git log查看得到</span></span><br></pre></td></tr></table></figure><p>有必要整理一下<code>git reset</code>命令的三个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br><span class="line"><span class="comment">#重置版本库头指针，且将这次提交之后的所有变更移动到暂存区</span></span><br><span class="line"></span><br><span class="line">$ git reset --mixed HEAD^</span><br><span class="line"><span class="comment">#默认参数，等同于 git reset HEAD^</span></span><br><span class="line"><span class="comment">#重置版本库头指针和暂存区，即这次提交之后的所有更改都留在工作区</span></span><br><span class="line"></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"><span class="comment">#重置版本库头指针、暂存区和工作区，即这次提交之后的所有更改都不在存在于当前状态</span></span><br></pre></td></tr></table></figure><p>在没有将之后的提交推送到远程仓库的情况下，<code>git reset --hard</code>是个很危险的操作。若是已经推送到远程仓库，使用<code>git pull</code>可以重新获得之后的版本提交。<br>若是在没有远程备份时使用<code>--hard</code>进行版本回退，又想恢复到之后的版本，在一定时间内（一般为30天）可以通过<code>git reflog</code>查看操作id，再使用<code>git reset --hard &lt;ID&gt;</code>恢复。</p><h3 id="stash储藏"><a href="#stash储藏" class="headerlink" title="stash储藏"></a>stash储藏</h3><p>有时手头的工作进行到一半，需要切换分支做一些其他事情，可以采用<code>git stash</code>命令将当前的工作区储藏起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line"><span class="comment">#储藏当前工作区</span></span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line"><span class="comment">#查看当前的stash储藏栈</span></span><br><span class="line"></span><br><span class="line">$ git stash apply</span><br><span class="line"><span class="comment">#应用栈顶的储藏内容，恢复工作区到之前的储藏状态</span></span><br><span class="line">$ git stash apply stash@&#123;2&#125;</span><br><span class="line"><span class="comment">#应用指定储藏内容</span></span><br><span class="line"></span><br><span class="line">$ git stash pop</span><br><span class="line"><span class="comment">#与apply类似，但从栈中删除该储藏内容</span></span><br></pre></td></tr></table></figure><hr><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认推送的为master主分支</span></span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果要推送其他分支，将该分支对应的名字来替换master即可</span></span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。<br>当你的小伙伴从远程库<code>clone</code>时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意：本地分支名称最好与远程分支保持一致。</span></span><br><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程。</p><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你对同样的文件也做了修改，并且试图推送。</p><p>这个时候会推送失败,因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单: 先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>如果<code>git pull</code>提示<code>“no tracking information”</code>，则说明本地分支和远程分支的链接关系没有创建，用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure><p>最后再将你改好的分支<code>push</code>到远程仓库。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>任何情况下都可以使用<code>git status</code>命令查看当前的版本控制状态（包括工作区、暂存区、仓库区），并给出当前状态下可能会用到的命令提示。<br>经常使用该命令是好习惯。</p><h3 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h3 id="配置git用户"><a href="#配置git用户" class="headerlink" title="配置git用户"></a>配置git用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name <span class="string">"your name"</span></span><br><span class="line">$ git config user.email <span class="string">"email@example.com"</span></span><br><span class="line"><span class="comment">#配置当前目录的git用户，加上--config参数时配置这台机器的所有git仓库</span></span><br></pre></td></tr></table></figure><h3 id="协议更改"><a href="#协议更改" class="headerlink" title="协议更改"></a>协议更改</h3><p>有时版本克隆是采用的是https协议，以至于每一次提交都需要输入用户名密码，很麻烦。而使用ssh协议就会方便很多，需要将当前的仓库协议进行更换。<br>事实上，重置远程仓库名为ssh协议地址就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote origin <span class="built_in">set</span>-url git@example.com....</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言碎碎念&quot;&gt;&lt;a href=&quot;#前言碎碎念&quot; class=&quot;headerlink&quot; title=&quot;前言碎碎念&quot;&gt;&lt;/a&gt;前言碎碎念&lt;/h2&gt;&lt;p&gt;自从使用Git作为版本控制工具以来，通过教程学习、手册查阅方式了解了Git的相关原理和Git的命令，能够顺利使用。但
      
    
    </summary>
    
      <category term="版本控制之Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B9%8BGit/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Bash" scheme="http://yoursite.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>如何更改Github上面托管的项目的默认显示语言</title>
    <link href="http://yoursite.com/2018/04/22/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E6%89%98%E7%AE%A1%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2018/04/22/如何更改Github上面托管的项目的默认显示语言/</id>
    <published>2018-04-22T10:41:32.000Z</published>
    <updated>2018-06-08T07:24:08.530Z</updated>
    
    <content type="html"><![CDATA[<p>最近将自己一门课的课程大作业，也算是一个小项目demo，放到了GitHub上面，由于项目里面包含许多下载的html文件，导致html代码远远的超过自己写的python代码，于是GitHub默认也就显示是html。</p><p>这种对于我这种有强迫症的人来说，简直就是不能忍受的。于是我就各种上网找解决方案。终于，在不懈的努力之后，让我给找到了，在这里分享给大家。</p><p>导致这种情况的主要原因是GitHub是使用Linguist来检测你的项目所使用的语言，Linguist具体的作用我个人猜测应该就是：统计你这个项目里面哪一种语言的代码量最多，就把这种语言作为当前这个项目的主语言,也就是默认显示语言。这种做法显然是很不合理的，你比如像python这种支持函数式编程而且崇尚语法简洁优雅的解释型脚本语言，它的代码量远远比不过其他的编译型语言(比如C/C++/Java)。</p><p>那么到底如何来解决这个问题呢？解决办法如下：</p><font face="微软雅黑" size="3" color="red">使用.gitattributes配置文件</font><p><strong> 具体做法是这样的：在你的GitHub代码仓库的根目录界面新建一个.gitattributes配置文件，如下图所示：</strong></p><p><img src="/2018/04/22/如何更改Github上面托管的项目的默认显示语言/1.png" alt="Github"></p><p>然后打开这个文件：把默认的显示语言（也就是统计的代码量最多的语言）全部改成你这个项目本来的语言。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.js linguist-language=Python　　</span><br><span class="line">*.css linguist-language=Python　　　</span><br><span class="line">*.html linguist-language=Python</span><br></pre></td></tr></table></figure><font face="微软雅黑" size="3" color="red">这几行代码的意思就是说：将以.js , .css , .html 为扩展名的文件都按照Python语言来统计。就是这么简单。这么直接！！！</font><p>好了，改完这些之后保存，再回到GitHub主界面就会看到默认的展示语言已经变成python了。主要的步骤就是这样，希望能够帮助到大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近将自己一门课的课程大作业，也算是一个小项目demo，放到了GitHub上面，由于项目里面包含许多下载的html文件，导致html代码远远的超过自己写的python代码，于是GitHub默认也就显示是html。&lt;/p&gt;
&lt;p&gt;这种对于我这种有强迫症的人来说，简直就是不能忍
      
    
    </summary>
    
      <category term="版本控制之Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B9%8BGit/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>关于惠普暗影精灵2 pro用一段时间之后，插上电源充不了电的问题</title>
    <link href="http://yoursite.com/2018/04/22/%E5%85%B3%E4%BA%8E%E6%83%A0%E6%99%AE%E6%9A%97%E5%BD%B1%E7%B2%BE%E7%81%B52-pro%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8F%92%E4%B8%8A%E7%94%B5%E6%BA%90%E5%85%85%E4%B8%8D%E4%BA%86%E7%94%B5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/22/关于惠普暗影精灵2-pro用一段时间之后，插上电源充不了电的问题/</id>
    <published>2018-04-22T06:33:59.000Z</published>
    <updated>2018-06-08T07:23:51.379Z</updated>
    
    <content type="html"><![CDATA[<p>去年5月份换的新电脑，用到现在大半年了。近几天来突然发现电脑插上电源充不了电，关机重启啥的都没有效果，于是尝试着上网找各种解决方案，终于，在试了N种解决方案之后，终于让我成功地找到了解决问题的办法。现在将我的解决方案分享出来，希望对大家有所帮助。</p><p>具体的操作步骤（<strong>仅针对惠普电脑，其他品牌的电脑不敢保证，不过个人觉得应该差不多</strong>）如下：</p><hr><ol><li><p>先将电脑关机；</p></li><li><p>在关机状态下按住键盘上的windows和V键；</p></li><li><p>再按住上面的两个键的同时，不松开，再按住电源键，三个键同时按住不放2-3秒钟；</p></li><li><p>松开全部的按键；</p></li><li><p>按电源键开机，看是否会进入一个Bios设置界面，即是否会提示502，如果提示的话则表示操作成功；</p></li><li><p>再重新启动电脑一次，问题即可解决。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年5月份换的新电脑，用到现在大半年了。近几天来突然发现电脑插上电源充不了电，关机重启啥的都没有效果，于是尝试着上网找各种解决方案，终于，在试了N种解决方案之后，终于让我成功地找到了解决问题的办法。现在将我的解决方案分享出来，希望对大家有所帮助。&lt;/p&gt;
&lt;p&gt;具体的操作步
      
    
    </summary>
    
      <category term="电脑技巧" scheme="http://yoursite.com/categories/%E7%94%B5%E8%84%91%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Computer Tricks" scheme="http://yoursite.com/tags/Computer-Tricks/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/21/hello-world/"/>
    <id>http://yoursite.com/2018/04/21/hello-world/</id>
    <published>2018-04-21T09:39:15.947Z</published>
    <updated>2018-06-08T07:22:47.719Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
